<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://ruihan.org/leetcode/breadth-first-search/notes/ rel=canonical><link rel="shortcut icon" href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.1.2, mkdocs-material-6.0.2"><title>Breadth-First Search (BFS) - RUIHAN.ORG</title><link rel=stylesheet href=../../../assets/stylesheets/main.38780c08.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.3f72e892.min.css><meta name=theme-color content=#000000><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=black data-md-color-accent=black> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#breadth-first-search class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=https://ruihan.org title=RUIHAN.ORG class="md-header-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> RUIHAN.ORG </span> <span class="md-header-nav__topic md-ellipsis"> Breadth-First Search (BFS) </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class="md-tabs md-tabs--active" aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../books/ class=md-tabs__link> Books </a> </li> <li class=md-tabs__item> <a href=../../../courses/ class=md-tabs__link> Courses </a> </li> <li class=md-tabs__item> <a href=../../ class="md-tabs__link md-tabs__link--active"> Leetcode </a> </li> <li class=md-tabs__item> <a href=../../../research/ class=md-tabs__link> Research </a> </li> <li class=md-tabs__item> <a href=../../../seedlabs/ class=md-tabs__link> SEED Labs </a> </li> <li class=md-tabs__item> <a href=../../../system-design/ class=md-tabs__link> System Design </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=https://ruihan.org title=RUIHAN.ORG class="md-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> RUIHAN.ORG </label> <div class=md-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1 type=checkbox id=nav-1> <label class=md-nav__link for=nav-1> Books <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Books data-md-level=1> <label class=md-nav__title for=nav-1> <span class="md-nav__icon md-icon"></span> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../books/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../books/accelerated-cpp/notes/ class=md-nav__link> Accelerated C++ </a> </li> <li class=md-nav__item> <a href=../../../books/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Datasets </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Courses <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Courses data-md-level=1> <label class=md-nav__title for=nav-2> <span class="md-nav__icon md-icon"></span> Courses </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../courses/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../courses/machine-learning-coursera/notes/ class=md-nav__link> Machine Learning (Coursera) </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/lec-notes/ class=md-nav__link> CS224N Lecture Notes </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/write-up/ class=md-nav__link> CS224N Write-up </a> </li> <li class=md-nav__item> <a href=../../../courses/coursera-dl4-cnn/notes/ class=md-nav__link> Convolutional Neural Networks </a> </li> <li class=md-nav__item> <a href=../../../courses/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Data Sets </a> </li> <li class=md-nav__item> <a href=../../../courses/6.431-probability/notes/ class=md-nav__link> 6.431 Probability </a> </li> <li class=md-nav__item> <a href=../../../courses/learning-from-data/notes.md class=md-nav__link> Learning From Data </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-system-design/notes/ class=md-nav__link> Nine Chapter System Design </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-dynamic-prog/notes/ class=md-nav__link> Nine Chapter Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../../courses/func-prog-in-scala/notes/ class=md-nav__link> Functional Programming Principles in Scala </a> </li> <li class=md-nav__item> <a href=../../../courses/applied-scrum-for-agile/notes/ class=md-nav__link> Applied Scrum for Agile Project Management </a> </li> <li class=md-nav__item> <a href=../../../courses/concurrent-prog-java/notes/ class=md-nav__link> Concurrent Programming in Java </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3 type=checkbox id=nav-3 checked> <label class=md-nav__link for=nav-3> Leetcode <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Leetcode data-md-level=1> <label class=md-nav__title for=nav-3> <span class="md-nav__icon md-icon"></span> Leetcode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../array/notes/ class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../../backtracking/notes/ class=md-nav__link> Backtracking </a> </li> <li class=md-nav__item> <a href=../../binary-search/notes/ class=md-nav__link> Binary Search </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Breadth-First Search (BFS) <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Breadth-First Search (BFS) </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#algorithm class=md-nav__link> Algorithm </a> <nav class=md-nav aria-label=Algorithm> <ul class=md-nav__list> <li class=md-nav__item> <a href=#the-maze-ii class=md-nav__link> The Maze II </a> </li> <li class=md-nav__item> <a href=#the-maze-iii class=md-nav__link> The Maze III </a> </li> <li class=md-nav__item> <a href=#pacific-atlantic-water-flow class=md-nav__link> Pacific Atlantic Water Flow </a> </li> <li class=md-nav__item> <a href=#longest-increasing-path-in-a-matrix class=md-nav__link> Longest Increasing Path in a Matrix </a> </li> <li class=md-nav__item> <a href=#walls-and-gates class=md-nav__link> Walls and Gates </a> </li> <li class=md-nav__item> <a href=#01-matrix class=md-nav__link> 01 Matrix </a> </li> <li class=md-nav__item> <a href=#surrounded-regions class=md-nav__link> Surrounded Regions </a> </li> <li class=md-nav__item> <a href=#best-meeting-point class=md-nav__link> Best Meeting Point </a> </li> <li class=md-nav__item> <a href=#number-of-islands class=md-nav__link> Number of Islands </a> </li> <li class=md-nav__item> <a href=#battleships-in-a-board class=md-nav__link> Battleships in a Board </a> </li> <li class=md-nav__item> <a href=#bus-routes class=md-nav__link> Bus Routes </a> </li> <li class=md-nav__item> <a href=#word-ladder class=md-nav__link> Word Ladder </a> </li> <li class=md-nav__item> <a href=#minimum-genetic-mutation class=md-nav__link> Minimum Genetic Mutation </a> </li> <li class=md-nav__item> <a href=#word-ladder-ii class=md-nav__link> Word Ladder II </a> </li> <li class=md-nav__item> <a href=#open-the-lock class=md-nav__link> Open the Lock </a> </li> <li class=md-nav__item> <a href=#evaluate-devision class=md-nav__link> Evaluate Devision </a> </li> <li class=md-nav__item> <a href=#399-evaluate-division class=md-nav__link> 399. Evaluate Division </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#compute-shortest-path-for-undirected-graphs class=md-nav__link> Compute shortest path for undirected graphs </a> <nav class=md-nav aria-label="Compute shortest path for undirected graphs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#the-maze-ii_1 class=md-nav__link> The Maze II </a> </li> <li class=md-nav__item> <a href=#shortest-distance-from-all-buildings class=md-nav__link> Shortest Distance from All Buildings </a> </li> <li class=md-nav__item> <a href=#shortest-path-visiting-all-nodes class=md-nav__link> Shortest Path Visiting All Nodes </a> </li> <li class=md-nav__item> <a href=#shortest-path-to-get-all-keys class=md-nav__link> Shortest Path to Get All Keys </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#compute-connected-components-for-undirected-graphs class=md-nav__link> Compute connected components for undirected graphs </a> <nav class=md-nav aria-label="Compute connected components for undirected graphs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#longest-increasing-path-in-a-matrix_1 class=md-nav__link> Longest Increasing Path in a Matrix </a> </li> <li class=md-nav__item> <a href=#number-of-connected-components-in-an-undirected-graph class=md-nav__link> Number of Connected Components in an Undirected Graph </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#bfs-topological-sorting class=md-nav__link> BFS Topological sorting </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../depth-first-search/notes/ class=md-nav__link> Depth-First Search (DFS) </a> </li> <li class=md-nav__item> <a href=../../dynamic-programming/notes/ class=md-nav__link> Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../graph/notes/ class=md-nav__link> Graph </a> </li> <li class=md-nav__item> <a href=../../heap/notes/ class=md-nav__link> Heap </a> </li> <li class=md-nav__item> <a href=../../interval/notes/ class=md-nav__link> Interval </a> </li> <li class=md-nav__item> <a href=../../linked-list/notes/ class=md-nav__link> Linked List </a> </li> <li class=md-nav__item> <a href=../../math/notes/ class=md-nav__link> Math </a> </li> <li class=md-nav__item> <a href=../../stack/notes/ class=md-nav__link> Stack </a> </li> <li class=md-nav__item> <a href=../../string/notes/ class=md-nav__link> String </a> </li> <li class=md-nav__item> <a href=../../tree/notes/ class=md-nav__link> Tree </a> </li> <li class=md-nav__item> <a href=../../trie/notes/ class=md-nav__link> Trie </a> </li> <li class=md-nav__item> <a href=../../union-find/notes/ class=md-nav__link> Union Find </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> Research <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Research data-md-level=1> <label class=md-nav__title for=nav-4> <span class="md-nav__icon md-icon"></span> Research </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../research/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../research/paper-reading/notes/ class=md-nav__link> Paper Reading </a> </li> <li class=md-nav__item> <a href=../../../research/coalition-game/notes/ class=md-nav__link> Coalition Game </a> </li> <li class=md-nav__item> <a href=../../../research/contextual-bandit/notes/ class=md-nav__link> Contextual Multi-Armed Bandit </a> </li> <li class=md-nav__item> <a href=../../../research/tfidf-score/notes/ class=md-nav__link> TF-IDF for Information Retrieval </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-5 type=checkbox id=nav-5> <label class=md-nav__link for=nav-5> SEED Labs <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="SEED Labs" data-md-level=1> <label class=md-nav__title for=nav-5> <span class="md-nav__icon md-icon"></span> SEED Labs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../seedlabs/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/applied-crypto/notes/ class=md-nav__link> Applied Cryptograph Notes </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/public-key-cryptography-and-pki/notes/ class=md-nav__link> Public Key Cryptography and PKI </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-6 type=checkbox id=nav-6> <label class=md-nav__link for=nav-6> System Design <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="System Design" data-md-level=1> <label class=md-nav__title for=nav-6> <span class="md-nav__icon md-icon"></span> System Design </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../system-design/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../system-design/browser/notes.md class=md-nav__link> How Browser Works </a> </li> <li class=md-nav__item> <a href=../../../system-design/concurrency/notes/ class=md-nav__link> Concurrency and Synchronization </a> </li> <li class=md-nav__item> <a href=../../../system-design/concepts/notes/ class=md-nav__link> Distributed System Concepts </a> </li> <li class=md-nav__item> <a href=../../../system-design/patterns/notes/ class=md-nav__link> Design Patterns </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/tinyurl/notes/ class=md-nav__link> How to Design TinyUrl </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/twitter/notes/ class=md-nav__link> How to Design Twitter </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/ticketmaster/notes/ class=md-nav__link> How to Design Ticketmaster </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#algorithm class=md-nav__link> Algorithm </a> <nav class=md-nav aria-label=Algorithm> <ul class=md-nav__list> <li class=md-nav__item> <a href=#the-maze-ii class=md-nav__link> The Maze II </a> </li> <li class=md-nav__item> <a href=#the-maze-iii class=md-nav__link> The Maze III </a> </li> <li class=md-nav__item> <a href=#pacific-atlantic-water-flow class=md-nav__link> Pacific Atlantic Water Flow </a> </li> <li class=md-nav__item> <a href=#longest-increasing-path-in-a-matrix class=md-nav__link> Longest Increasing Path in a Matrix </a> </li> <li class=md-nav__item> <a href=#walls-and-gates class=md-nav__link> Walls and Gates </a> </li> <li class=md-nav__item> <a href=#01-matrix class=md-nav__link> 01 Matrix </a> </li> <li class=md-nav__item> <a href=#surrounded-regions class=md-nav__link> Surrounded Regions </a> </li> <li class=md-nav__item> <a href=#best-meeting-point class=md-nav__link> Best Meeting Point </a> </li> <li class=md-nav__item> <a href=#number-of-islands class=md-nav__link> Number of Islands </a> </li> <li class=md-nav__item> <a href=#battleships-in-a-board class=md-nav__link> Battleships in a Board </a> </li> <li class=md-nav__item> <a href=#bus-routes class=md-nav__link> Bus Routes </a> </li> <li class=md-nav__item> <a href=#word-ladder class=md-nav__link> Word Ladder </a> </li> <li class=md-nav__item> <a href=#minimum-genetic-mutation class=md-nav__link> Minimum Genetic Mutation </a> </li> <li class=md-nav__item> <a href=#word-ladder-ii class=md-nav__link> Word Ladder II </a> </li> <li class=md-nav__item> <a href=#open-the-lock class=md-nav__link> Open the Lock </a> </li> <li class=md-nav__item> <a href=#evaluate-devision class=md-nav__link> Evaluate Devision </a> </li> <li class=md-nav__item> <a href=#399-evaluate-division class=md-nav__link> 399. Evaluate Division </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#compute-shortest-path-for-undirected-graphs class=md-nav__link> Compute shortest path for undirected graphs </a> <nav class=md-nav aria-label="Compute shortest path for undirected graphs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#the-maze-ii_1 class=md-nav__link> The Maze II </a> </li> <li class=md-nav__item> <a href=#shortest-distance-from-all-buildings class=md-nav__link> Shortest Distance from All Buildings </a> </li> <li class=md-nav__item> <a href=#shortest-path-visiting-all-nodes class=md-nav__link> Shortest Path Visiting All Nodes </a> </li> <li class=md-nav__item> <a href=#shortest-path-to-get-all-keys class=md-nav__link> Shortest Path to Get All Keys </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#compute-connected-components-for-undirected-graphs class=md-nav__link> Compute connected components for undirected graphs </a> <nav class=md-nav aria-label="Compute connected components for undirected graphs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#longest-increasing-path-in-a-matrix_1 class=md-nav__link> Longest Increasing Path in a Matrix </a> </li> <li class=md-nav__item> <a href=#number-of-connected-components-in-an-undirected-graph class=md-nav__link> Number of Connected Components in an Undirected Graph </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#bfs-topological-sorting class=md-nav__link> BFS Topological sorting </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=breadth-first-search>Breadth-First Search<a class=headerlink href=#breadth-first-search title="Permanent link">&para;</a></h1> <h2 id=algorithm>Algorithm<a class=headerlink href=#algorithm title="Permanent link">&para;</a></h2> <p>BFS search a graph by first explore all the vertices that are adjacent to the source vertex <code>s</code>, then explore the adjacent vertices of those already examined in layer-by-layer fashion until all the vertices are visited.</p> <p>```text tab="The psudo code" BFS (graph G, start vertex s) [ all nodes initially unexplored ] -- mark s as explored -- let Q = queue data structure, initialized with s -- while Q not empty: -- remove the first node of Q, call it v -- for each edge(v,w) : -- if w unexplored -- mark w as explored -- add w to Q (at the end) <div class=highlight><pre><span></span><code>## BFS properties

1. Runtime complexity $\Theta(|V| + |E|)$.
2. It calculate __shortest path__ from the source $s$ to the vertex $v$.
3. It build a breadth-first tree, CLRS called predecessor subgraph.
4. If edge $(u, v)$ in the BFS tree, the simple path from source vertext $s$ to
   $u$ is equal to the simple path from $s$ to $v$, or differ by 1.
5. Simple path from a source vertex $s$ to a destination vertex $v$ is equal to
   the laterâ€™s __level label__.
6. If $v_1, v_2, \cdots, v_n$ is the vertex enqueued in a certain point, $v_1$
   is the head and $v_n$ is the back, then the level label of $v_1$ is either
   equal to level label of $v_n$ or less by 1. Also the level label of all the
   vertices in the queue is non-decreasing from head to tail.
   __In other words, at a certain time the enqueued vertices at most comes from two different levels.__

## Search

1. unweighted edges
2. Bi-directional search, (Speed up Dijkastra of 6.006)
3. At all time, the level of nodes in queue at most differ by 1
4. The relationship between BFS and DFS (The Maze II)

!!! Note &quot;BFS tips for board and grid problems&quot;
    1. When push a pair of coordinate to a BFS queue, one way of doing it is using
       `pair&lt;int, int&gt;`. Another way is to convert to a number by `p = i * n + j`,
        and retrieve the coordinate by `i = p / n` and `j = p % n`.
    2. The BFS starting point and &quot;target&quot; are important, give a second thought
       about where should the search start and how it terminate.
    3. `visitted[m][n]` is not necessary sometimes. See whether you can modify
       the original borad/matrix/grid/maze to reflect whether the element has
       already been accessed or not.
    4. In a borad or maze like input, searching neighbor cells requires you to
       manipulate indexes for accessing its neighbors. We do this by defining two
       &quot;offset&quot; coordinates arrays. `int x[4] = {-1, 0, 1, 0}; int y[4] = {0, 1, 0, -1};`
    5. The BFS queue doesn&#39;t necessarily start with one element pushed. It could
       be __&quot;multi-end&quot; BFS__. Like in problme [Pacific Atlantic Water Flow](#pacific-atlantic-water-flow)
       and [Longest Increasing Path in a Matrix](#longest-increasing-path-in-a-matrix),
       one could init the queue with all possible starting node then in use a while
       to visit all the node towards finding the optimal path.
    6. The &quot;multi-end&quot; BFS not only can make the BFS level by level (each round
       of for loop visited one level of nodes), but also can make use some optimal
       feature of BFS, like the BFS solution of Walls and Gates.
    7. The BFS while loop could include another while loop to interate throught
       total `q.size()` nodes. This is different from the &quot;oracle&quot; BFS solution
       from CRLS, but sometime could be useful. For example: [Longest Increasing Path in a Matrix](#longest-increasing-path-in-a-matrix).

### The Maze

```C++ tab=&quot;DFS&quot;
class Solution {
public:
    bool hasPath(vector&lt;vector&lt;int&gt;&gt;&amp;maze, vector&lt;int&gt;&amp; start, vector&lt;int&gt;&amp; destination) {
        int m = maze.size();
        int n = m ? maze[0].size() : 0;
        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));

        return dfs_helper(maze, start, destination, visited);
    }

    void dfs_helper(vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;int&gt;&amp; start,
                    vector&lt;int&gt;&amp; destination, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {

        if (start[0] == destination[0] &amp;&amp; start[1] == destination[1]) {
            return true;
        }

        int x[4] = {0, -1, 0, 1};
        int y[4] = {-1, 0, 1, 0};

        bool res = false;
        for (int k = 0; k &lt; 4; k++) {
            int a = start[0] + x[k];
            int b = start[1] + y[k];

            // walk untill hit the wall
            while (a &gt;= 0 &amp;&amp; b &gt;= 0 &amp;&amp; a &lt; maze.size() &amp;&amp; b &lt; maze[0].size90 &amp;&amp; maze[a][b] == 0) {
                a += x[k];
                b += y[k];
            }

            if (!visited[a - x[k]][b - y[k]]) {
                visited[a - x[k]][b - y[k]] = true;
                vector&lt;int&gt; new_start({a - x[k], b - y[k]});
                res != dfs_helper(maze, new_start, destination, visited);
            }
        }

        return res;
    }
};
</code></pre></div></p> <p>```C++ tab="BFS" class Solution { public: bool hasPath(vector<vector\&lt;int>>&amp;maze, vector<int>&amp; start, vector<int>&amp; destination) { int m = maze.size(); int n = m ? maze[0].size() : 0;</p> <div class=highlight><pre><span></span><code>    vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));
    queue&lt;vector&lt;int&gt;&gt; q;
    q.push(start);

    int x[4] = {0, -1, 0, 1};
    int y[4] = {-1, 0, 1, 0};

    while (!q.empty()) {
        vector&lt;int&gt; s = q.front(); q.pop();

        if (s[0] == destination[0] &amp;&amp; s[1] == destination[1]) {
            return true;
        }

        for (int k = 0; k &lt; 4; k++) {
            int a = s[0] + x[k];
            int b = s[1] + y[k];

            while (a &gt;= 0 &amp;&amp; b &gt;= 0 &amp;&amp; a &lt; m &amp;&amp; b &lt; n &amp;&amp; maze[a][b] == 0) {
                a += x[k];
                b += y[k];
            }

            if (!visited[a - x[k]][b - y[k]]) {
                q.push(vector&lt;int&gt;({a - x[k], b - y[k]}));
                visited[a - x[k]][b - y[k]] = true;
            }
        }
    }

    return false;
}
</code></pre></div> <p>}; ``` </p> <h3 id=the-maze-ii>The Maze II<a class=headerlink href=#the-maze-ii title="Permanent link">&para;</a></h3> <ul> <li>BFS can computer shortest path, we need additional memory to keep the optimal values.</li> <li>we update the corresponding destination cell in <code>distance</code> vector when we found a smaller distane can reach it from any direction. the final result will be in <code>distance[destination[0]][destination[1]]</code>.</li> <li>If we don't want to use so much memory, we can use a flag to mark when the BFS switch levels.</li> <li>This solution is essentially to use BFS to solve the weighted graph problem as Victor mentioned in 6006 R15.</li> <li>Compare this solution to the Dijkastra solution. The update distance matrix is essentially the relaxiation step. <code>C++ tab="" class Solution { public: int shortestDistance(vector&lt;vector&lt;int&gt;&gt;&amp; maze, vector&lt;int&gt;&amp; start, vector&lt;int&gt;&amp; destination) { int m = maze.size(); int n = m ? maze[0].size() : 0; if (m == 0) return 0; vector&lt;vector&lt;int&gt;&gt; distance(m, vector&lt;int&gt;(n, INT_MAX)); queue&lt;vector&lt;int&gt;&gt; q; q.push(start); distance[start[0]][start[1]] = 0; int x[4] = {-1, 0, 1, 0}; int y[4] = {0, 1, 0, -1}; while (!q.empty()) { vector&lt;int&gt; s = q.front(); q.pop(); for (int k = 0; k &lt; 4; k++) { int a = s[0] + x[k]; int b = s[1] + y[k]; int count = 0; while (a &gt;= 0 &amp;&amp; b &gt;= 0 &amp;&amp; a &lt; m &amp;&amp; b &lt; n &amp;&amp; maze[a][b] == 0) { a += x[k]; b += y[k]; count++; } // notice here is a optimize if (distance[s[0]][s[1]] + count &lt; distance[a - x[k]][b - y[k]]) { distance[a - x[k]][b - y[k]] = distance[s[0]][s[1]] + count; q.push(vector&lt;int&gt;({a - x[k], b - y[k]})); /* could use emplace({a - x[k], b - y[k]}) */ } } } return distance[destination[0]][destination[1]] == INT_MAX ? -1 : distance[destination[0]][destination[1]]; } };</code></li> </ul> <div class="admonition note"> <p class=admonition-title>Note</p> <ul> <li>Based on the BFS solution, we can use a priority queue. Then the problem is very similar to the Dijkastra algorithm.</li> <li>The discussion about the improvement in leetcode forum is very interesting.</li> </ul> </div> <h3 id=the-maze-iii>The Maze III<a class=headerlink href=#the-maze-iii title="Permanent link">&para;</a></h3> <ul> <li>This problem is aksing for output the shortest path to reach the destination.</li> <li>The idea is to use a <code>distance[i][i]</code> and <code>result[i][j]</code>. we should keep update the <code>distance[i][j]</code> and <code>result[i][j]</code> with smaller distance and lexicographical order. The hardest part is that there is two constrains. While using BFS, How could we ensure the two constrains are met, and also we are not missing any possible path. (i.e. missed to push a path to the BFS queue.)</li> <li>A trick we can make use of is we searching in the lexicographically order. such as <code>down</code>, <code>left</code>, <code>right</code>, <code>up</code>. However, we face a problem: the <strong>smallest lexicon order result may not be the shortest distance</strong>. Think this through.</li> <li>We need to used additional memory to record that piece of information beside the memory used to keep the minimum distance.</li> </ul> <p>```C++ tab="BFS" hl_lines="54" class Solution { public: string findShortestWay(vector<vector\&lt;int>>&amp; maze, vector<int>&amp; start, vector<int>&amp; destination) { int m = maze.size(); int n = m ? maze[0].size() : 0;</p> <div class=highlight><pre><span></span><code>    if (m == 0) return 0;

    vector&lt;vector&lt;int&gt;&gt; distance(m, vector&lt;int&gt;(n, INT_MAX));
    vector&lt;vector&lt;string&gt;&gt; result(m, vector&lt;string&gt;(n, &quot;&quot;));
    queue&lt;vector&lt;int&gt;&gt; q;
    q.push(start);
    distance[start[0]][start[1]] = 0;

    char path[4] = {&#39;d&#39;, &#39;l&#39;, &#39;r&#39;, &#39;u&#39;};
    int x[4] = {1, 0, 0, -1};
    int y[4] = {0, -1, 1, 0};

    while (!q.empty()) {
        vector&lt;int&gt; s = q.front(); q.pop();

        for (int k = 0; k &lt; 4; k++) {
            int a = s[0] + x[k];
            int b = s[1] + y[k];
            int count = 0;
            /* continue if no wall */
            while (a &gt;= 0 &amp;&amp; b &gt;= 0 &amp;&amp; a &lt; m &amp;&amp; b &lt; n &amp;&amp; maze[a][b] == 0) {
                /* run over the destination */
                if (a == destination[0] &amp;&amp; b == destination[1]){
                    if (distance[s[0]][s[1]] + count &lt; distance[a][b]) {
                        distance[a][b] = distance[s[0]][s[1]] + count;
                        result[a][b] = result[s[0]][s[1]] + path[k];
                    } else if (distance[s[0]][s[1]] + count == distance[a][b]) {
                        string tmp = result[s[0]][s[1]] + path[k];
                        /* same distance, smaller lexicon */
                        if (tmp.compare(result[a][b]) &lt; 0) {
                            result[a][b] = tmp;
                        }
                    }
                }

                a += x[k];
                b += y[k];
                count++;
            }

            /* hit a wall, have to retreat &quot;0&quot;, current a, b is in wall or off maze */
            if (distance[s[0]][s[1]] + count &lt; distance[a - x[k]][b - y[k]]) {
                distance[a - x[k]][b - y[k]] = distance[s[0]][s[1]] + count;
                result[a - x[k]][b - y[k]] = result[s[0]][s[1]] + path[k];
                q.push(vector&lt;int&gt;({a - x[k], b - y[k]}));
            } else if (distance[s[0]][s[1]] + count == distance[a - x[k]][b - y[k]]) {
                string tmp = result[s[0]][s[1]] + path[k];
                /* same distance, smaller lexicon */
                if (tmp.compare(result[a - x[k]][b - y[k]]) &lt; 0) {
                    result[a - x[k]][b - y[k]] = tmp;
                    /* possible path, need to search it again */
                    q.push(vector&lt;int&gt;({a - x[k], b - y[k]}));
                }
            }
        }
    }

    return distance[destination[0]][destination[1]] == INT_MAX ? &quot;impossible&quot; : result[destination[0]][destination[1]];
}
</code></pre></div> <p>}; <code></code>C++ tab="DFS" class Solution { public: string findShortestWay(vector<vector\&lt;int>>&amp; maze, vector<int>&amp; ball, vector<int>&amp; hole) { return roll(maze, ball[0], ball[1], hole, 0, 0, 0, "", pair<string, int>() = {"impossible", INT_MAX}); } string roll(vector<vector\&lt;int>>&amp; maze, int rowBall, int colBall, const vector<int>&amp; hole, int distRow, int distCol, int steps, const string&amp; path, pair<string, int>&amp; res) { if (steps &lt; res.second) { if (distRow != 0 || distCol != 0) { while ((rowBall + distRow) &gt;= 0 &amp;&amp; (rowBall + distRow) &lt; maze.size() &amp;&amp; (colBall + distCol) &gt;= 0 &amp;&amp; (colBall + distCol) &lt; maze[0].size() &amp;&amp; maze[rowBall + distRow][colBall + distCol] != 1) { rowBall += distRow; colBall += distCol; ++steps; if (rowBall == hole[0] &amp;&amp; colBall == hole[1] &amp;&amp; steps &lt; res.second) { res = {path, steps}; } } } if (maze[rowBall][colBall] == 0 || steps + 2 &lt; maze[rowBall][colBall]) { maze[rowBall][colBall] = steps + 2; if (distRow == 0) roll(maze, rowBall, colBall, hole, 1, 0, steps, path + "d", res); if (distCol == 0) roll(maze, rowBall, colBall, hole, 0, -1, steps, path + "l", res); if (distCol == 0) roll(maze, rowBall, colBall, hole, 0, 1, steps, path + "r", res); if (distRow == 0) roll(maze, rowBall, colBall, hole, -1, 0, steps, path + "u", res); } } return res.first; } }; ```</p> <p>```C++ tab="Dijkstra algoirthm" class Vertex { public: int x, y, dist; std::string path; Vertex(int x, int y, int dist, std::string path) { this-&gt;x = x; this-&gt;y = y; this-&gt;dist = dist; this-&gt;path = path; } Vertex(int x, int y) { this-&gt;x = x; this-&gt;y = y; this-&gt;dist = INT_MAX; this-&gt;path = ""; } bool equals(Vertex v) { return this-&gt;x == v.x &amp;&amp; this-&gt;y == v.y; } bool equals(int x, int y) { return this-&gt;x == x &amp;&amp; this-&gt;y == y; } }; class Solution { private: // coordinates and path strings for the four directions. std::vector<int> directions = {-1, 0, 1, 0, -1}; std::vector<std::string> paths = {"u", "r", "d", "l"}; // can't roll if it's boundry, wall or hole. bool canRoll(vector<vector\&lt;int>> &amp;maze, Vertex hole, int x, int y) { int m = maze.size(), n = maze[0].size(); if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) return maze[x][y] != 1 &amp;&amp; !hole.equals(x, y); else return false; }</p> <div class=highlight><pre><span></span><code>Vertex roll(vector&lt;vector&lt;int&gt;&gt; &amp;maze, Vertex curr, Vertex hole, int dx,
            int dy, std::string path) {
    int x = curr.x, y = curr.y, steps = curr.dist;
    while (canRoll(maze, hole, x + dx, y + dy))
    {
        x += dx;
        y += dy;
        steps++;
    }
    // if couldn&#39;t roll due to hole, then return vertex corresponding to the hole.
    if (hole.equals(x + dx, y + dy))
    {
        x += dx;
        y += dy;
    }
    return Vertex(x, y, steps, curr.path + path);
}
</code></pre></div> <p>public: /<em> * to form a pq based on the increasing order of distances, and if same * distance then sorting based on lexicographic order. </em>/ struct Compare { bool operator()(const Vertex &amp;a, const Vertex &amp;b) { return a.dist &gt; b.dist || a.dist == b.dist &amp;&amp; a.path &gt; b.path; } }; /<em> * Applying Dijkstra's algorithm here. * We treat hole as a gate here. The trick is look for holes while rolling * the back in a particular direction. So, the pq here contains the vertices * before gates as well as the holes. So, using dijkstra, when we pop a hole * from pq, we know its that. </em>/ string findShortestWay(vector<vector\&lt;int>>&amp; maze, vector<int>&amp; ball, vector<int>&amp; hole) { int m = maze.size(), n = maze[0].size(); std::priority_queue<vertex, std::vector\&lt;vertex>, Compare> pq; Vertex startVertex(ball[0], ball[1], 0, ""), holeVertex(hole[0], hole[1]); std::unordered_set<int> visited; pq.push(startVertex); while (!pq.empty()) { Vertex curr = pq.top(); visited.insert(curr.x * n + curr.y); pq.pop(); if (curr.equals(holeVertex)) { return curr.path; } for (int i = 0; i &lt; directions.size() - 1; i++) { Vertex newStart = roll(maze, curr, holeVertex, directions[i], directions[i + 1], paths[i]); if (visited.find(newStart.x * n + newStart.y) == visited.end()) pq.push(newStart); } } return "impossible"; } }; ``` </p> <h3 id=pacific-atlantic-water-flow>Pacific Atlantic Water Flow<a class=headerlink href=#pacific-atlantic-water-flow title="Permanent link">&para;</a></h3> <ul> <li>Using DFS and two matrices to record the states and then to loop through the result check for both possible flow cases.</li> <li>The key is how to start the DFS? should we initiate the DFS in each <code>(i, j)</code>? Here we can see it is more efficient if that we start from the edges. Notice we mark <code>visited[i][j] = true</code> immediately enter the helper function. <code>C++ class Solution { public: vector&lt;pair&lt;int, int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); int n = m ? matrix[0].size() : 0; vector&lt;vector&lt;int&gt;&gt; p_visited(m, vector&lt;int&gt;(n, 0)); vector&lt;vector&lt;int&gt;&gt; a_visited(m, vector&lt;int&gt;(n, 0)); vector&lt;pair&lt;int, int&gt;&gt; res; for (int i = 0; i &lt; m; i++) { helper(matrix, i, 0, p_visited); helper(matrix, i, n - 1, a_visited); } for (int j = 0; j &lt; n; j++) { helper(matrix, 0, j, p_visited); helper(matrix, m - 1, j, a_visited); } for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (p_visited[i][j] &amp;&amp; a_visited[i][j]) { //res.push_back(pair&lt;int, int&gt;(i, j)); res.push_back({i, j}); } } } return res; } void helper (vector&lt;vector&lt;int&gt;&gt;&amp; mat, int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; visited) { int m = mat.size(); int n = m ? mat[0].size() : 0; int x[] = {0, -1, 0, 1}; int y[] = {-1, 0, 1, 0}; visited[i][j] = true; /* visite mat[i][j] first */ /* and then explore its neighbors */ for (int k = 0; k &lt; 4; k++) { int p = i + x[k]; int q = j + y[k]; if (p &gt;= 0 &amp;&amp; p &lt; m &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; n &amp;&amp; !visited[p][q] &amp;&amp; mat[i][j] &lt;= mat[p][q]) { helper(mat, p, q, visited); } } } };</code></li> </ul> <p>```C++ tab="DFS solution" class Solution { public: vector<pair\&lt;int, int>> pacificAtlantic(vector<vector\&lt;int>>&amp; matrix) { int m = matrix.size(); int n = m ? matrix[0].size() : 0;</p> <div class=highlight><pre><span></span><code>    vector&lt;vector&lt;bool&gt;&gt; vPacific(m, vector&lt;bool&gt;(n, false));
    vector&lt;vector&lt;bool&gt;&gt; vAtlantic(m, vector&lt;bool&gt;(n, false));
    queue&lt;pair&lt;int, int&gt;&gt; qPacific;
    queue&lt;pair&lt;int, int&gt;&gt; qAtlantic;

    for (int i = 0; i &lt; m; ++i) {
        qPacific.push({i, 0});
        vPacific[i][0] = true;
        qAtlantic.push({i, n - 1});
        vAtlantic[i][n - 1] = true;
    }

    for (int i = 0; i &lt; n; ++i) {
        qPacific.push({0, i});
        vPacific[0][i] = true;
        qAtlantic.push({m - 1, i});
        vAtlantic[m - 1][i] = true;
    }

    bfs_helper(matrix, qPacific, vPacific);
    bfs_helper(matrix, qAtlantic, vAtlantic);

    vector&lt;pair&lt;int, int&gt;&gt; res;
    for (int i = 0; i &lt; m; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            if (vPacific[i][j] &amp;&amp; vAtlantic[i][j]) {
                res.push_back({i, j});
            }
        }
    }

    return res;
}

void bfs_helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, queue&lt;pair&lt;int, int&gt;&gt;&amp; q, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) {
    int m = matrix.size();
    int n = m ? matrix[0].size() : 0;
    int x[4] = {0, -1, 0, 1};
    int y[4] = {-1, 0, 1, 0};

    while (!q.empty()) {
        int a = q.front().first;
        int b = q.front().second;
        q.pop();
        for (int k = 0; k &lt; 4; ++k) {
            int u = a + x[k];
            int v = b + y[k];

            if (u &lt; 0 || u &gt;= m || v &lt; 0 || v &gt;= n || visited[u][v] || matrix[a][b] &gt; matrix[u][v]) continue;
            visited[u][v] = true;
            q.push({u, v});
        }
    }
}
</code></pre></div> <div class="admonition warning"> <p class=admonition-title>Warning</p> <p>Notice your terminate condition <code>matrix[a][b] &gt; matrix[u][v]</code> in the DFS solution indicates your search direction cannot not go from high to low. The search direction is from low to high (or equal). This is to optimize the search since we don't have to revisite a node later. </p> </div> <h3 id=longest-increasing-path-in-a-matrix>Longest Increasing Path in a Matrix<a class=headerlink href=#longest-increasing-path-in-a-matrix title="Permanent link">&para;</a></h3> <p>BFS solution * Each cell should possibly be the starting cell of the longest increasing path. So we have to search starting from each one of the cells. It seems the running time is quadratic. How to optimize? * use markers matrix to mark whether the <code>matrix[i][j]</code> have greater neighbors, <code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code> -&gt; 1, 2, 4, 8. * The do BFS only looking for the directions that have greater neighbors. The idea is very similar to the "branch cutting" in DFS. <code>C++ class Solution { public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); int n = m ? matrix[0].size() : 0; vector&lt;vector&lt;int&gt;&gt; markers(m, vector&lt;int&gt;(n, 0)); int x[4] = {-1, 0, 1, 0}; int y[4] = {0, 1, 0, -1}; int res = 0; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { for (int k = 0; k &lt; 4; k++) { int p = i + x[k]; int q = j + y[k]; if (p &lt; 0 || p &gt;= m || q &lt; 0 || q &gt;= m) continue; if (matrix[p][q] &gt; matrix[i][j]) markers[i][j] ^= (1 &lt;&lt; k); } } } for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { int level = 0; if (markers[i][j] &gt; 0) { level = 0; queue&lt;int&gt; q; q.push(i * n + j); while (!q.empty()) { int a = q.front() / n; int b = q.front() % n; q.pop(); bool flag = true; for (int k = 0; k &lt; 4; k++) { int u = a + x[k]; int v = b + y[k]; if (u &lt; 0 || u &gt;= m || v &lt; 0 || v &gt;= m) continue; if (has_greater_neighbor(markers[a][b], k)) { q.push(u * n + v); if (flag) { level++; flag = false; } } } } } res = max(res, level); } } return res; } bool has_greater_neighbor(int flags, int k) { return (flags &gt;&gt; k) &amp; 1; } };</code></p> <p>BFS solution II</p> <ul> <li>BFS can find the shortest path. How can you use BFS to find the longest path? In this problem, we are not use BFS's shortest path properpy, we make use of BFS's property of finding the connected components. We can imagine each increasing path is a connected component, we need to find out the largest one. Notice how the solution construct the search structure (for loop inside the while loop).</li> <li>By construct the search structure in this way, the len is actually the level of nodes from all the peaks identified in the first nested for loops.</li> </ul> <p>```Java tab="Java solution" class Solution { public int longestIncreasingPath(int[][] matrix) { private final int[][] dirs = {{1, 0}, {-1, 0},{0, 1}, {0, -1}}; private boolean ispeak(int[][] matrix, boolean[][] marked, int i, int j) { if (i &gt; 0 &amp;&amp; !marked[i-1][j] &amp;&amp; matrix[i-1][j] &gt; matrix[i][j]) return false; if (i &lt; matrix.length-1 &amp;&amp; !marked[i+1][j] &amp;&amp; matrix[i+1][j] &gt; matrix[i][j]) return false; if (j &gt; 0 &amp;&amp; !marked[i][j-1] &amp;&amp; matrix[i][j-1] &gt; matrix[i][j]) return false; if (j &lt; matrix[0].length-1 &amp;&amp; !marked[i][j+1] &amp;&amp; matrix[i][j+1] &gt; matrix[i][j]) return false; return true; } public int longestIncreasingPath(int[][] matrix) { if (matrix.length == 0 || matrix[0].length == 0) return 0; int len = 0; LinkedList<int[]> queue = new LinkedList&lt;&gt;(); boolean[][] marked = new boolean[matrix.length][matrix[0].length]; for (int i = 0; i &lt; matrix.length; i++) { for (int j = 0; j &lt; matrix[0].length; j++) { if (ispeak(matrix, marked, i, j)) queue.add(new int[]{i, j}); } } while (!queue.isEmpty()) { len++; int size = queue.size(); for (int i = 0; i &lt; size; i++) { int[] p = queue.poll(); marked[p[0]][p[1]] = true; for (int j = 0; j &lt; 4; j++) { int r = p[0]+dirs[j][0], c = p[1]+dirs[j][1]; if (r &gt;= 0 &amp;&amp; r &lt; matrix.length &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; matrix[0].length &amp;&amp; !marked[r][c] &amp;&amp; ispeak(matrix, marked, r, c)) { if (matrix[r][c] != matrix[p[0]][p[1]]) queue.add(new int[]{r, c}); } } } } return len; } } } <div class=highlight><pre><span></span><code>!!! Note
    This BFS is not the same as the classic BFS routine from CLRS. It is a
    generalized BFS approach, which can be transformed to a problem to find the
    connected components.

DFS solution

* we can also use DFS for this problem, it turns out DFS is the simpliest solution.

```C++ tab=&quot;DFS solution&quot;
class Solution {
public:
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int m = matrix.size();
        int n = m ? matrix[0].size() : 0;

        if (n == 0) return 0;
        vector&lt;vector&lt;int&gt;&gt; cache(m, vector&lt;int&gt;(n, 0));
        int res = 1;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                int len = dfs_helper(matrix, i, j, m, n, cache);
                res = max(res, len);
            }
        }

        return res;
    }

    int dfs_helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int i, int j, int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; cache) {
        if (cache[i][j]) return cache[i][j];
        int x[4] = {-1, 0, 1, 0};
        int y[4] = {0, 1, 0, -1};
        int res = 1;
        for (int k = 0; k &lt; 4; k++) {
            int p = i + x[k];
            int q = j + y[k];
            if (p &lt; 0 || p &gt;= m || q &lt; 0 || q &gt;= n || matrix[p][q] &lt;= matrix[i][j]) continue;
            int len = 1 + dfs_helper(matrix, p, q, m, n, cache);
            res = max(res, len);
        }
        cache[i][j] = res;
        return res;
    }
};
</code></pre></div></p> <h3 id=walls-and-gates>Walls and Gates<a class=headerlink href=#walls-and-gates title="Permanent link">&para;</a></h3> <p>BFS solution</p> <ul> <li>We push all the gate to the queue at once, then BFS to update the room. This makes use of the optimal character of BFS and bring us some optimization.</li> <li>Proof correctness: If init the queue with all gates, BFS alternate between gates, once BFS explore one level of rooms for a particular gate, it switches to explore the same level or next level rooms for another gate. The level is the distance from room to gate. Suppose room R1 is visited at the first time from G1, then if R1 is visited again via G2, the distance from G2 to R1 is possible to be the same as G1 to R1, or greater than G1 to R1 by 1. <strong>The assigned nearest distance from room to gate never be able to reduce further in future.</strong> Then the first assigned distance value for a room will be the nearest one.</li> </ul> <p>```C++ tab="" class Solution { public: void wallsAndGates(vector<vector\&lt;int>>&amp; rooms) { int m = rooms.size(); int n = m ? rooms[0].size() : 0;</p> <div class=highlight><pre><span></span><code>    int x[4] = {-1, 0, 1, 0};
    int y[4] = {0, 1, 0, -1};

    queue&lt;pair&lt;int, int&gt;&gt; q;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (rooms[i][j] == 0) { // start from each gate 
                q.push({i, j});
            }
        }
    }

    while (!q.empty()) {
        int a = q.front().first;
        int b = q.front().second;
        q.pop();
        for (int k = 0; k &lt; 4; k++) {
            int u = a + x[k];
            int v = b + y[k];
            if (u &lt; 0 || u &gt;= m || v &lt; 0 || v &gt;= n || rooms[u][v] != INT_MAX) {
                continue;
            }

            rooms[u][v] = rooms[a][b] + 1;
            q.push({u, v});
        }
    }
}
</code></pre></div> <p>}; <code>DFS solution * I initially start with each `INF` cell and search for 0. the issue is we have to pass the original `i`, `j`, in case we reach the base case to update the `INF` cell. * Another trick is how to handle the repeated searching the same empty room. Extra space like `visited[m][n]` will work. but a better way to handle it is what we did in the below solution. We check if `d &gt; ma[i][j]`, if `d &gt; 0`, the `d &gt; mat[i][j]` also make sure we update `mat[i][j]` with a smaller value because the initial value of `INF` cell is `INT_MAX`. This is different from DFS because DFS can ensure the shortest path. * The time complexity is $O(m^2n^2)$. The space complexity is from the stack. It is definitely not constant.</code>C++ class Solution { public: void wallsAndGates(vector<vector\&lt;int>>&amp; rooms) { int m = rooms.size(); int n = m ? rooms[0].size() : 0; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (rooms[i][j] == 0) { // start from each gate, not room helper(rooms, i, j, 0); } } } } /<em> i, j are the starting point. </em>/ void helper(vector<vector\&lt;int>>&amp; mat, int i, int j, int d) { int m = mat.size(); int n = m ? mat[0].size() : 0; int x[4] = {-1, 0, 1, 0}; int y[4] = {0, 1, 0, -1}; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || mat[i][j] &lt; d) { return; } // have already made sure d &lt; mat[i][j] mat[i][j] = d; for (int k = 0; k &lt; 4; k++) { int a = i + x[k]; int b = j + y[k]; helper(mat, a, b, d + 1); } } }; ```</p> <div class="admonition note"> <p class=admonition-title>multi-end BFS</p> <p>Notice this implementation of BFS is different from triditional BFS. It start with a queue that have more than one element. Some people call this <a href=https://leetcode.com/problems/walls-and-gates/discuss/72748/benchmarks-of-dfs-and-bfs>multi-end BFS</a>. It is perform better than the original BFS, The time complexity is <span><span class=MathJax_Preview>O(mn)</span><script type=math/tex>O(mn)</script></span></p> </div> <h3 id=01-matrix>01 Matrix<a class=headerlink href=#01-matrix title="Permanent link">&para;</a></h3> <h3 id=surrounded-regions>Surrounded Regions<a class=headerlink href=#surrounded-regions title="Permanent link">&para;</a></h3> <ul> <li>We first mark the boundary 'O', then start BFS from each 'O'. If it cannot reach the special marks, we capture the cell.</li> <li>This solution is starting from each of inner 'O' and search the mark at the boundary. The solution is TLE due to more inner 'O's than boundary 'O's.</li> </ul> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=kt>void</span> <span class=n>solve</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;&gt;&amp;</span> <span class=n>board</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>board</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>m</span> <span class=o>?</span> <span class=n>board</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>x</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>-1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>};</span>
        <span class=kt>int</span> <span class=n>y</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>-1</span><span class=p>};</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>j</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>m</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>j</span> <span class=o>==</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;O&#39;</span> <span class=o>?</span> <span class=sc>&#39;-&#39;</span> <span class=o>:</span> <span class=sc>&#39;X&#39;</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;O&#39;</span><span class=p>)</span> <span class=p>{</span>
                    <span class=kt>bool</span> <span class=n>flag</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
                    <span class=n>queue</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>q</span><span class=p>;</span>
                    <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>({</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>});</span>
                    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
                        <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>first</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>second</span><span class=p>;</span>
                        <span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
                        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                            <span class=kt>int</span> <span class=n>u</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
                            <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=n>y</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
                            <span class=k>if</span> <span class=p>(</span><span class=n>u</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>u</span> <span class=o>&gt;=</span> <span class=n>m</span> <span class=o>||</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>v</span> <span class=o>&gt;=</span> <span class=n>n</span> <span class=o>||</span> <span class=n>board</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;X&#39;</span><span class=p>)</span> <span class=p>{</span>
                                <span class=k>continue</span><span class=p>;</span>
                            <span class=p>}</span>

                            <span class=k>if</span> <span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;O&#39;</span><span class=p>)</span> <span class=p>{</span>
                                <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>({</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>});</span>
                            <span class=p>}</span>

                            <span class=k>if</span> <span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span><span class=p>)</span> <span class=p>{</span>
                                <span class=n>flag</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
                                <span class=k>break</span><span class=p>;</span>
                            <span class=p>}</span>
                        <span class=p>}</span>
                        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>flag</span><span class=p>)</span>
                            <span class=k>break</span><span class=p>;</span>
                    <span class=p>}</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>flag</span><span class=p>)</span>
                        <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;X&#39;</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>j</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>m</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>j</span> <span class=o>==</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span> <span class=o>?</span> <span class=sc>&#39;O&#39;</span> <span class=o>:</span> <span class=sc>&#39;X&#39;</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div> <ul> <li>Instead searching whether a 'O' have an outlet. We can discover all 'O's that lead to edge 'O's and mark them, then all the rest 'O's are captured.</li> <li>Specifically, starting from every 'O' at the edge, using BFS to search all the 'O's outside the 'X's, all these 'O's that cannot be captured. Compare to solution 1, this ideas is thinking â€œout of the boxâ€, instead of thinking inside 'O's, we take care outside 'O's first.</li> <li>Similar problems: <a href=#walls-and-gates>Walls and Gates</a>, <a href=#shortest-distance-from-all-buildings>Shortest Distance from All Buildings</a>.</li> </ul> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=kt>void</span> <span class=n>solve</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;&gt;&amp;</span> <span class=n>board</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>board</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>m</span> <span class=o>?</span> <span class=n>board</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>

        <span class=c1>// bfs search from boundary &#39;O&#39;s</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>j</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>i</span> <span class=o>==</span> <span class=n>m</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>j</span> <span class=o>==</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;O&#39;</span><span class=p>)</span>
                        <span class=n>bfs_helper</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;O&#39;</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;X&#39;</span><span class=p>;</span> <span class=c1>// capture all inner &#39;O&#39;s</span>
                <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;O&#39;</span><span class=p>;</span> <span class=c1>// flip back the marks</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// helper function to mark &quot;outside&quot; &#39;O&#39; as &#39;-&#39;</span>
    <span class=kt>void</span> <span class=n>bfs_helper</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;&gt;&amp;</span> <span class=n>board</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>board</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>m</span> <span class=o>?</span> <span class=n>board</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>x</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>-1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>};</span>
        <span class=kt>int</span> <span class=n>y</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>-1</span><span class=p>};</span>

        <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;-&#39;</span><span class=p>;</span>
        <span class=n>queue</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>q</span><span class=p>;</span>
        <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>({</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>});</span>
        <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
            <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>first</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>second</span><span class=p>;</span>
            <span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
                <span class=kt>int</span> <span class=n>u</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
                <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=n>y</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>u</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>u</span> <span class=o>&lt;</span> <span class=n>m</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>board</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;O&#39;</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>({</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>});</span>
                    <span class=n>board</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;-&#39;</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div> <p>!!! Notes "Tips ä»¥ä¸Šä¸¤ä¸ª solution è¶³ä»¥è¯´æ˜ŽBFSçš„æœç´¢æ–¹å‘å’Œæœç´¢ç›®æ ‡éžå¸¸é‡è¦ã€‚å·§å¦™è½¬åŒ–æœç´¢ç›®æ ‡å¯ä»¥ä½¿å¾—codeå¾ˆå¥½å†™ï¼Œæ›´ç®€æ´ã€‚</p> <h3 id=best-meeting-point>Best Meeting Point<a class=headerlink href=#best-meeting-point title="Permanent link">&para;</a></h3> <ul> <li>At the first attempt, I tried to use BFS to do search level by level, which can exhaust all the possible distances from 1 to 0. Unfortunately, it is TLE in the OJ.</li> <li>Following from the idea in problem Minimum Moves to <a href=#equal-array-elements-ii>Equal Array Elements II</a>, we can use math method to calculate the median of the x and y coordinates.</li> <li>The worst case time complexity is <span><span class=MathJax_Preview>O(mn\log mn)</span><script type=math/tex>O(mn\log mn)</script></span>, since there are at most <span><span class=MathJax_Preview>m\times n</span><script type=math/tex>m\times n</script></span> "1" in the grid.</li> </ul> <p>```C++ "Median solution" class Solution { public: int minTotalDistance(vector<vector\&lt;int>>&amp; grid) { int m = grid.size(); int n = m ? grid[0].size() : 0;</p> <div class=highlight><pre><span></span><code>    vector&lt;int&gt; rows, cols;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] == 1) {
                rows.push_back(i);
                cols.push_back(j);
            }
        }
    }

    return minDistance(rows) + minDistance(cols);
}

int minDistance(vector&lt;int&gt; vec) {
    int n = vec.size();
    sort(vec.begin(), vec.end());
    int l = 0, r = n - 1;
    int res = 0;
    while (l &lt; r) res += vec[r--] - vec[l++];

    return res;
}
</code></pre></div> <p>}; <code></code>C++ "Median solution II" class Solution { public: int minTotalDistance(vector<vector\&lt;int>>&amp; grid) { int m = grid.size(); int n = m ? grid[0].size() : 0; vector<int> rows, cols; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == 1) { rows.push_back(i); cols.push_back(j); } } } sort(cols.begin(), cols.end()); int l = 0, r = rows.size() - 1; int res = 0; while (l &lt; r) res += rows[r] - rows[l] + cols[r--] - cols[l++]; return res; } }; ```</p> <p>```C++ tab="BFS" class Solution { public: int minTotalDistance(vector<vector\&lt;int>>&amp; grid) { int m = grid.size(); int n = m ? grid[0].size() : 0; int res = INT_MAX;</p> <div class=highlight><pre><span></span><code>    vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, 0));
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] == 1) {
                bfs_helper(grid, i, j, dist);
            }
        }
    }
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (res &gt; dist[i][j]) {
                res = dist[i][j];
            }
        }
    }

    return res;
}

void bfs_helper(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp;dist) {
    int m = grid.size();
    int n = m ? grid[0].size() : 0;

    int x[4] = {-1, 0, 1, 0};
    int y[4] = {0, 1, 0, -1};

    vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));

    int level = 1;
    queue&lt;pair&lt;int, int&gt;&gt; q;
    q.push({i, j});
    visited[i][j] = true;
    while (!q.empty()) {
        int len = q.size();
        for (int l = 0; l &lt; len; l++) {
            int a = q.front().first;
            int b = q.front().second;
            q.pop();
            for (int k = 0; k &lt; 4; k++) {
                int u = a + x[k];
                int v = b + y[k];
                if (u &gt;= 0 &amp;&amp; u &lt; m &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; n &amp;&amp; !visited[u][v]) {
                    dist[u][v] += level;
                    visited[u][v] = true;
                    q.push({u, v});
                }
            }
        }
        level++;
    }
}
</code></pre></div> <p>}; ``` </p> <h3 id=number-of-islands>Number of Islands<a class=headerlink href=#number-of-islands title="Permanent link">&para;</a></h3> <h3 id=battleships-in-a-board>Battleships in a Board<a class=headerlink href=#battleships-in-a-board title="Permanent link">&para;</a></h3> <h3 id=bus-routes>Bus Routes<a class=headerlink href=#bus-routes title="Permanent link">&para;</a></h3> <h3 id=word-ladder>Word Ladder<a class=headerlink href=#word-ladder title="Permanent link">&para;</a></h3> <h3 id=minimum-genetic-mutation>Minimum Genetic Mutation<a class=headerlink href=#minimum-genetic-mutation title="Permanent link">&para;</a></h3> <h3 id=word-ladder-ii>Word Ladder II<a class=headerlink href=#word-ladder-ii title="Permanent link">&para;</a></h3> <h3 id=open-the-lock>Open the Lock<a class=headerlink href=#open-the-lock title="Permanent link">&para;</a></h3> <h3 id=evaluate-devision>Evaluate Devision<a class=headerlink href=#evaluate-devision title="Permanent link">&para;</a></h3> <h3 id=399-evaluate-division>399. Evaluate Division<a class=headerlink href=#399-evaluate-division title="Permanent link">&para;</a></h3> <p>Solution BFS <code>C++ tab="C++ BFS" class Solution { public: vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) { unordered_map&lt;string, vector&lt;pair&lt;string, double&gt;&gt;&gt; graph; for (int i = 0; i &lt; equations.size(); i++) { graph[equations[i][0]].push_back({equations[i][1], values[i]}); graph[equations[i][0]].push_back({equations[i][0], 1.0}); graph[equations[i][1]].push_back({equations[i][0], 1.0 / values[i]}); graph[equations[i][1]].push_back({equations[i][1], 1.0}); } vector&lt;double&gt; res; for (auto&amp; qr: queries ) { if (graph.find(qr[0]) == graph.end() || graph.find(qr[1]) == graph.end()) { res.push_back(-1); continue; } queue&lt;pair&lt;string, double&gt;&gt; q; unordered_set&lt;string&gt; visited; q.push({qr[0], 1.0}); visited.insert(qr[0]); bool find = false; while (!q.empty() &amp;&amp; !find) { auto t = q.front(); q.pop(); if (t.first == qr[1]) { res.push_back(t.second); find = true; break; } for (auto a: graph[t.first]) { if (visited.find(a.first) == visited.end()) { a.second *= t.second; q.push(a); visited.insert(a.first); } } } if (!find) res.push_back(-1.0); } return res; } };</code></p> <p>Solution 2 DFS</p> <p>```C++ tab="C++ DFS" class Solution { public: vector<double> calcEquation(vector<pair\&lt;string, string>> equations, vector<double>&amp; values, vector<pair\&lt;string, string>> queries) {</p> <div class=highlight><pre><span></span><code>    int m = equations.size();
    int n = queries.size();
    vector&lt;double&gt; res(n, -1);
    set&lt;string&gt; s;
    for (auto equation : equations) {
        s.insert(equation.first);
        s.insert(equation.second);
    }

    for (int i = 0; i &lt; n; i++) {
        vector&lt;string&gt; query({queries[i].first, queries[i].second});
        if (s.count(query[0]) &amp;&amp; s.count(query[1])) {
            vector&lt;bool&gt; visited(m, 0);
            res[i] = helper(equations, values, query, visited);
        }
    }

    return res;
}

// Parameter visited here is to help the search.
double helper (vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;string&gt; query, vector&lt;bool&gt;visited) {
    int m = equations.size();

    //base case, writing in seperate loop is more efficient O(n)
    for (int i = 0; i &lt; m; i++) {
        if (equations[i].first == query[0] &amp;&amp; equations[i].second == query[1]) {
            return values[i];
        }

        if (equations[i].first == query[1] &amp;&amp; equations[i].second == query[0]) {
            return 1 / values[i];
        }
    }

    // not found do DFS
    for (int i = 0; i &lt; m; i++) {
        if (equations[i].first == query[0] &amp;&amp; !visited[i]) {
            visited[i] = true;
            double t = values[i] * helper(equations, values, {equations[i].second, query[1]}, visited);
            if (t &gt; 0) return t;
            visited[i] = false;
        }

        if (equations[i].second == query[0] &amp;&amp; !visited[i]) {
            visited[i] = true;
            double t = (1 / values[i]) * helper(equations, values, {equations[i].first, query[1]}, visited);
            if (t &gt; 0) return t;
            visited[i] = false;
        }
    }

    return -1.0;
}
</code></pre></div> <p>}; <code>Solution 3 Floydâ€“Warshall All pair shortest path</code>C++ tab="C++ Floyd-Warshall" ```</p> <h2 id=compute-shortest-path-for-undirected-graphs>Compute shortest path for undirected graphs<a class=headerlink href=#compute-shortest-path-for-undirected-graphs title="Permanent link">&para;</a></h2> <h3 id=the-maze-ii_1><a href=#the-maze-ii>The Maze II</a><a class=headerlink href=#the-maze-ii_1 title="Permanent link">&para;</a></h3> <h3 id=shortest-distance-from-all-buildings>Shortest Distance from All Buildings<a class=headerlink href=#shortest-distance-from-all-buildings title="Permanent link">&para;</a></h3> <ul> <li>Similar to <a href=#walls-and-gates>Walls and Gates</a>, We should search from the "dst" (buildings) to "src" (empty land), while the problem is asking search from empty land to buildings.</li> <li>We need a 2D array to record the distance obtained by searching. The result is obtained at last after we finish the searching. Attention: we have also need to check whether the new building can reach all buildings. So use another 2D array and a counter num_buildings to check it can reach all.</li> </ul> <p>```C++ tab="" class Solution { public: int shortestDistance(vector<vector\&lt;int>>&amp; grid) { int m = grid.size(); int n = m ? grid[0].size() : 0;</p> <div class=highlight><pre><span></span><code>    int num_buildings = 0;
    vector&lt;vector&lt;int&gt;&gt; dist1(m, vector&lt;int&gt;(n, 0));
    vector&lt;vector&lt;int&gt;&gt; reach(m, vector&lt;int&gt;(n, 0));

    int x[4] = {-1, 0, 1, 0};
    int y[4] = {0, 1, 0, -1};

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] == 1) {
                num_buildings++;
                queue&lt;int&gt; q;
                vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));

                q.push(i * n + j);
                int level = 1; // grid[a][b] is level 0, grid[u][v] is level 1
                while (!q.empty()) {
                    int l = q.size();
                    for (int s = 0; s &lt; l; s++) { // BFS level by level
                        int a = q.front() / n;
                        int b = q.front() % n;
                        q.pop();
                        for (int k = 0; k &lt; 4; k++) {
                            int u = a + x[k];
                            int v = b + y[k];
                            if (u &gt;= 0 &amp;&amp; u &lt; m &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; n &amp;&amp; grid[u][v] == 0 &amp;&amp; !visited[u][v]) {
                                dist1[u][v] += level;
                                reach[u][v]++; // use to count num of 1s that reach this 0.
                                visited[u][v] = true;
                                q.push(u * n + v);
                            }
                        }
                    }
                    level++;
                }
            }
        }
    }

    int res = INT_MAX;
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (grid[i][j] == 0 &amp;&amp; reach[i][j] == num_buildings) {
                res = min(res, dist1[i][j]);
            }
        }
    }

    return res == INT_MAX ? -1 : res;
}
</code></pre></div> <p>}; <code>* We can modify the original 2D array to record which cell is visited and which isn't so as to optimize the space complexity. Each time we start BFS from a building `grid[i][j]=1`, the land will be decreased by `1`. So after the first BFS, all `grid[i][j]=0` becomes `grid[i][j]=-1`. The decreasing of `grid[i][j]` is equivalent to use the visited variables. * similar to Solution 1, we use a 2D array `dist[i][j]` to record the distances. This distance is `dist[i][j]` used to record each BFS started from a building (`grid[i][j]=1`), not the global distances. To accumulate all the distance from 1s, we have to use another 2D array sum to record it.</code>C++ tab="Optimized BFS solution" hl_lines="30,31,32,33" class Solution { public: int shortestDistance(vector<vector\&lt;int>>&amp; grid) { int m = grid.size(); int n = m ? grid[0].size() : 0; int res = INT_MAX; int counter = 0; vector<vector\&lt;int>> sum = grid; int x[4] = {0, -1, 0, 1}; int y[4] = {-1, 0, 1, 0}; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (grid[i][j] == 1) { vector<vector\&lt;int>> dist = grid; queue<int> q; q.push(i * n + j); res = INT_MAX; while (!q.empty()) { int a = q.front() / n; int b = q.front() % n; q.pop(); for (int k = 0; k &lt; 4; ++k) { int u = a + x[k]; int v = b + y[k]; if (u &lt; m &amp;&amp; u &gt;= 0 &amp;&amp; v &lt; n &amp;&amp; v &gt;= 0 &amp;&amp; grid[u][v] == counter) { grid[u][v]--; // Mark this potential building position is visited in prev round dist[u][v] = dist[a][b] + 1; sum[u][v] += dist[u][v] - 1; res = min(res, sum[u][v]); q.push(u * n + v); } } } counter--; // mark as visited } } } return res == INT_MAX ? -1 : res; } }; ```</p> <h3 id=shortest-path-visiting-all-nodes>Shortest Path Visiting All Nodes<a class=headerlink href=#shortest-path-visiting-all-nodes title="Permanent link">&para;</a></h3> <h3 id=shortest-path-to-get-all-keys>Shortest Path to Get All Keys<a class=headerlink href=#shortest-path-to-get-all-keys title="Permanent link">&para;</a></h3> <h2 id=compute-connected-components-for-undirected-graphs>Compute connected components for undirected graphs<a class=headerlink href=#compute-connected-components-for-undirected-graphs title="Permanent link">&para;</a></h2> <h3 id=longest-increasing-path-in-a-matrix_1><a href=#longest-increasing-path-in-a-matrix>Longest Increasing Path in a Matrix</a><a class=headerlink href=#longest-increasing-path-in-a-matrix_1 title="Permanent link">&para;</a></h3> <h3 id=number-of-connected-components-in-an-undirected-graph>Number of Connected Components in an Undirected Graph<a class=headerlink href=#number-of-connected-components-in-an-undirected-graph title="Permanent link">&para;</a></h3> <ul> <li>Build the undirected graph using adjacency list from the edge list representation.</li> <li>Call BFS in a for loop and use a <code>visited</code> vector to mark the status of the vertex explorations.</li> <li>Direct transform the above BFS solution to a DFS solution.</li> </ul> <p>```C++ tab="BFS solution" class Solution { public: int countComponents(int n, vector<pair\&lt;int, int>>&amp; edges) { vector<vector\&lt;int>> graph(n, vector<int>(0)); vector<bool> visited(n, false);</p> <div class=highlight><pre><span></span><code>    for (auto edge : edges) {
        graph[edge.first].push_back(edge.second);
        graph[edge.second].push_back(edge.first);
    }

    queue&lt;int&gt; q;
    int count = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (!visited[i]) {
            q.push(i);
            visited[i] = true;
            while (!q.empty()) {
                int t = q.front(); q.pop();
                for (auto a : graph[t]) {
                    if (!visited[a]) {
                        visited[a] = true;
                        q.push(a);
                    }
                }
            }

            count++;
        }
    }

    return count;
}
</code></pre></div> <p>}; <code></code>C++ tab="DFS solution" class Solution { public: int countComponents(int n, vector<pair\&lt;int, int>>&amp; edges) { vector<vector\&lt;int>> graph(n, vector<int>(0)); vector<bool> visited(n, false); int count = 0; for (auto edge : edges) { graph[edge.first].push_back(edge.second); graph[edge.second].push_back(edge.first); } for (int i = 0; i &lt; n; ++i) { if (!visited[i]) { dfs_helper(graph, visited, i); count++; } } return count; } void dfs_helper(vector<vector\&lt;int>>&amp; graph, vector<bool>&amp; visited, int i) { visited[i] = true; for (auto a : graph[i]) { if (!visited[a]) { dfs_helper(graph, visited, a); } } } }; ```</p> <p>```C++ tab="Union-Find solution" class Solution { vector<int> parent; public: int countComponents(int n, vector<pair\&lt;int, int>>&amp; edges) { parent = vector<int>(n, -1);</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; n; ++i) parent[i] = i;

    for (auto edge : edges) {
        int p = root(edge.first);
        int q = root(edge.second);
        if (p != q) parent[q] = p;
    }

    int count = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (parent[i] == i) {
            count++;
        }
    }

    return count;
}

int root(int i) {
    while (i != parent[i]) i = parent[i];
    return i;
}
</code></pre></div> <p>}; ```</p> <h2 id=bfs-topological-sorting>BFS Topological sorting<a class=headerlink href=#bfs-topological-sorting title="Permanent link">&para;</a></h2> <p>Apply BFS in DAG topological sorting requires to start with the vertices that have <code>0</code> indegree, namely the source vertices. We need a <strong>queue</strong> and a <code>indegree</code> vector for solving topological sorting problems. The BFS queue may start with more than one source vertices because topological sorted graph may start with two or more vertices (indegree == 0). When BFS visit an adjacent vertex of the queue-front vertex, the indegree of this visited vertex should be decreased by 1, as we "visited" this arc. If the indegree of the visited vertex is reduced to 0, we push it to the queue. The idea of using BFS in topological sorting is to explore frontier of the vertices that currently have <code>0</code> non-visited arcs leading to the vertices (indegree is 0).</p> <ul> <li>What if the given graph have a single vertex?</li> <li>How to check whether the topological sorting is unique or not?</li> <li>How to output all the unique topological sorted sequence of vertices?</li> </ul> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../../binary-search/notes/ class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Previous </span> Binary Search </div> </div> </a> <a href=../../depth-first-search/notes/ class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Depth-First Search (DFS) </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Rui Han </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/vendor.77e55a48.min.js></script> <script src=../../../assets/javascripts/bundle.9554a270.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script> <script>
        app = initialize({
          base: "../../..",
          features: ['navigation.tabs'],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>